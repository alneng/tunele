name: Backend CI/CD

on:
  push:
    branches:
      - master
      # - develop
    paths:
      - "src/backend/**"
  workflow_dispatch: # Allows manual execution of the workflow
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "preview"
        type: choice
        options:
          - preview
          - production

# Prevent concurrent deployments to the same environment
concurrency:
  group: backend-deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}-api
  CONTAINER_NAME: tunele-api

jobs:
  # Run lint check before build
  lint:
    name: Lint
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "yarn"

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Run linting
        run: yarn lint

  # Run tests before build
  test:
    name: Test
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "yarn"

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Run tests
        run: yarn test

  # Build Docker image only after lint and test pass
  build:
    name: Build
    needs: [lint, test]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.tags.outputs.image_tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Pushes to master are tagged as: latest, {sha}
      # [Disabled] Pushes to develop are tagged as: preview, preview-{sha}
      # Pushes from workflow_dispatch are tagged based on the environment selected
      - name: Set image tags
        id: tags
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          # elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          #   echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:preview,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:preview-${{ github.sha }}" >> $GITHUB_OUTPUT
          #   echo "image_tag=preview-${{ github.sha }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ inputs.environment }}" == "production" ]]; then
              echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT
              echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
            else
              echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:preview,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:preview-${{ github.sha }}" >> $GITHUB_OUTPUT
              echo "image_tag=preview-${{ github.sha }}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./src/backend/docker/Dockerfile
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to server after successful build
  deploy:
    name: Deploy
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: prod
    if: success()

    steps:
      - name: Configure SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Set deployment variables
        id: deploy-vars
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "container_name=${{ env.CONTAINER_NAME }}" >> $GITHUB_OUTPUT
            echo "port_mapping=7600:7600" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          # elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          #   echo "container_name=${{ env.CONTAINER_NAME }}-preview" >> $GITHUB_OUTPUT
          #   echo "port_mapping=7601:7600" >> $GITHUB_OUTPUT
          #   echo "image_tag=preview-${{ github.sha }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ inputs.environment }}" == "production" ]]; then
              echo "container_name=${{ env.CONTAINER_NAME }}" >> $GITHUB_OUTPUT
              echo "port_mapping=7600:7600" >> $GITHUB_OUTPUT
              echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
            else
              echo "container_name=${{ env.CONTAINER_NAME }}-preview" >> $GITHUB_OUTPUT
              echo "port_mapping=7601:7600" >> $GITHUB_OUTPUT
              echo "image_tag=preview-${{ github.sha }}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Deploy to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e # Exit on any error
            
            # Change to project directory
            PROJECT_DIR="/home/${{ secrets.SERVER_USER }}/${{ env.CONTAINER_NAME }}"
            cd "$PROJECT_DIR"

            # Set compose file and project name based on environment
            if [[ "${{ steps.deploy-vars.outputs.image_tag }}" == "preview"* ]]; then
              COMPOSE_FILE="docker-compose.preview.yml"
              ENV_FILE=".env.preview"
              HEALTH_URL="http://localhost:7601/api/health"
            else
              COMPOSE_FILE="docker-compose.prod.yml"
              ENV_FILE=".env"
              HEALTH_URL="http://localhost:7600/api/health"
            fi

            # Download latest configuration files from repository
            echo "Downloading latest configuration files from repository..."
            
            # GitHub raw file URLs - using commit SHA for exact version
            REPO_URL="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}"
            
            # Download docker-compose files
            echo "Downloading docker-compose file..."
            curl -f -o "$COMPOSE_FILE.new" "$REPO_URL/src/backend/docker/$COMPOSE_FILE" || {
              echo "ERROR: Failed to download $COMPOSE_FILE"
              exit 1
            }
            
            # Backup existing files and replace with new ones
            echo "Updating configuration files..."
            
            # Backup docker-compose file only if it exists (handles first-run case)
            if [[ -f "$COMPOSE_FILE" ]]; then
              cp "$COMPOSE_FILE" "$COMPOSE_FILE.backup"
            fi
            mv "$COMPOSE_FILE.new" "$COMPOSE_FILE"
            
            # Update the image in the compose file
            sed -i "s|image: ghcr.io/.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.deploy-vars.outputs.image_tag }}|" "$COMPOSE_FILE"

            # Pull the latest images
            echo "Pulling new images..."
            docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" pull

            # Function to check service health
            check_health() {
              local max_attempts=30
              local attempt=1
              
              echo "Checking service health..."
              while [ $attempt -le $max_attempts ]; do
                if curl -f "$HEALTH_URL" >/dev/null 2>&1; then
                  echo "Service is healthy!"
                  return 0
                fi
                echo "Attempt $attempt/$max_attempts: Service not healthy yet, waiting..."
                sleep 5
                ((attempt++))
              done
              
              echo "Service failed to become healthy after $max_attempts attempts"
              return 1
            }

            # Function to rollback
            rollback() {
              echo "Rolling back to previous version..."
              
              # Restore original compose file if backup exists
              if [[ -f "$COMPOSE_FILE.backup" ]]; then
                echo "Restoring original $COMPOSE_FILE..."
                cp "$COMPOSE_FILE.backup" "$COMPOSE_FILE"
                
                # Start containers with original file
                docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --remove-orphans
                
                if check_health; then
                  echo "Rollback successful!"
                  # Clean up failed deployment files
                  rm -f "$COMPOSE_FILE.backup"
                else
                  echo "ERROR: Rollback failed! Manual intervention required."
                  exit 1
                fi
              else
                echo "WARNING: No backup file found for rollback (first deployment?)"
                echo "Attempting to continue with current configuration..."
              fi
            }

            # Deploy
            echo "Starting deployment..."
            
            # Start new containers without stopping old ones first
            docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --no-recreate --remove-orphans
            
            # Wait a moment for containers to initialize
            sleep 15
            
            # Check if new deployment is healthy
            if check_health; then
              echo "New deployment is healthy, recreating containers with new config..."
              
              # Now recreate containers with new config to ensure clean state
              docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --force-recreate --remove-orphans
              
              # Final health check after recreation
              if check_health; then
                echo "Deployment successful! Replacing original compose file..."
                
                # Clean up backup files
                rm -f "$COMPOSE_FILE.backup"
                
                # Clean up old images
                echo "Cleaning up old images..."
                docker image prune -f --filter "until=24h"
              else
                echo "Post-recreation health check failed, rolling back..."
                rollback
                exit 1
              fi
            else
              echo "New deployment failed health check, rolling back..."
              rollback
              exit 1
            fi
            
          ENDSSH
